---
import Animate from '@lib/components/svg/animations/Animate.astro';
import AnimateMotion from '@lib/components/svg/animations/AnimateMotion.astro';
import G from '@lib/components/svg/builtin/G.astro';
import Path2 from '@lib/components/svg/builtin/Path2.astro';
import Rect from '@lib/components/svg/builtin/Rect.astro';
import BaseLayout from '@lib/layouts/BaseLayout.astro';
import { IF } from '@lib/util/comperator';
import { chance, irand, pick, rand } from '@lib/util/stokhos';

function looping_keypoints(n: number) {
  // random start offset on the path (0–1 or 0–0.5 if you prefer)
  const start_point = Math.random(); // or Math.random() * 0.5;

  const loops = n - 1; // number of full laps

  // --- keyPoints ---
  // Pattern for L loops with start offset s:
  //   s; 1;0; 1;0; ...; 1;0; s
  // That gives 2*L + 2 entries.
  const keyPointsArray: number[] = [start_point];
  for (let i = 0; i < loops; i++) {
    keyPointsArray.push(1, 0);
  }
  keyPointsArray.push(start_point);
  const key_points = keyPointsArray.join(';');

  // --- keyTimes ---
  // We keep your idea:
  //   0; t1;t1; t2;t2; ...; t_L;t_L; 1
  // That is 2*L + 2 entries, matching keyPoints.
  let s = 0;
  const dx = 1 / n;
  const keyTimesArray: number[] = [0];

  for (let i = 0; i < loops; i++) {
    const time = s + dx + Math.random() * dx * 0.9;
    s += dx;
    keyTimesArray.push(time, time);
  }

  keyTimesArray.push(1);
  const key_times = keyTimesArray.join(';');

  return { key_points, key_times };
}

let n = 30;
let dy = 3;
---

<BaseLayout title="playground:looping-keypoints" fullScreen={true}>
  <svg viewBox="0 0 100 100">
    <G translate={[50, 50]}>
      <G translate={[-25, -((n - 1) * dy) / 2]}>
        {
          Array.from({ length: n }).map((_, i) => {
            let ks = looping_keypoints(irand(4, 16));
            let width = irand(1, 4);
            let height = irand(1, 4);
            let fillOpacity = rand(0.5, 1);
            let color = pick(['red', 'green', 'blue']);
            let duration = rand(16, 32);
            let dasharray = chance(0.25) ? [rand(0.25, 2), rand(0.25, 2)] : undefined;

            return (
              <G translate={[0, i * dy]}>
                <G stroke-width={0.25}>
                  <Path2
                    d={[['h', 50]]}
                    stroke={color}
                    id="mpath-0"
                    stroke-dasharray={dasharray?.join(' ')}
                  >
                    {IF(!!dasharray, () => {
                      return (
                        <Animate
                          attributeName="stroke-dashoffset"
                          to={`${dasharray?.reduce((a, b) => a + b, 0) ?? 0 * 2}`}
                          begin="0s"
                          dur="1s"
                          repeatCount="indefinite"
                        />
                      );
                    })}
                  </Path2>
                </G>
                <Rect
                  fill={color}
                  width={width}
                  x={-width / 2}
                  height={height}
                  y={-height / 2}
                  fill-opacity={fillOpacity}
                >
                  <AnimateMotion
                    keyPoints={ks.key_points}
                    keyTimes={ks.key_times}
                    mpath="#mpath-0"
                    dur={`${duration}s`}
                    begin="0s"
                    repeatCount={'indefinite'}
                  />
                </Rect>
              </G>
            );
          })
        }
      </G>
    </G>
  </svg>
</BaseLayout>

<style>
  svg {
    width: 100%;
    height: 100%;
  }
</style>
