---
import Animate from '@lib/components/svg/animations/Animate.astro';
import G from '@lib/components/svg/builtin/G.astro';
import Path2 from '@lib/components/svg/builtin/Path2.astro'; // Using Path2
import Rect from '@lib/components/svg/builtin/Rect.astro';
import BaseLayout from '@lib/layouts/BaseLayout.astro';
import { range } from '@lib/util/iter';
import { clamp } from '@lib/util/map';
import { chance, irand, pick } from '@lib/util/stokhos';

const grid_map = new Map<string, boolean>();
const paths: [number, number][][] = [];

const rows = 256;
const cols = 256;
const CELL_SIZE = 4; // For drawing

// Helper to generate random HSL colors
let colors = [
  [15, 100, 50],
  [30, 90, 60],
  [90, 80, 20],
  [140, 40, 20],
  [220, 20, 40],
];

const randomColor = () =>
  `hsl(${pick(
    colors.map((c) => {
      let saturation_offset = irand(-10, 20);
      let saturation = c[1] + saturation_offset;
      let lightness_offset = irand(-10, 15);
      let lightness = c[2] + lightness_offset;

      saturation = clamp(saturation, 0, 100);
      lightness = clamp(lightness, 0, 100);

      return [c[0], saturation, lightness].join(' ');
    })
  )}%)`;

// 1. Initialize the grid
for (let y = 0; y < rows; y++) {
  for (let x = 0; x < cols; x++) {
    grid_map.set(`${x},${y}`, false); // false = unvisited
  }
}

// *** NEW: Create a shuffled list of all cells ***
const all_cells: [number, number][] = [];
for (let y = 0; y < rows; y++) {
  for (let x = 0; x < cols; x++) {
    all_cells.push([x, y]); // Note: (x, y) order
  }
}
all_cells.sort((a, b) => 0.5 - Math.random());

// 2. Iterate through every cell in a random order to start paths
for (const [x, y] of all_cells) {
  // If this cell is already part of a path, skip it
  if (grid_map.get(`${x},${y}`)) continue;

  // This is a new, unvisited cell. Start a new path here.
  const current_path: [number, number][] = [];
  let current_x = x;
  let current_y = y;

  // Mark starting cell as visited and add it to the path
  grid_map.set(`${current_x},${current_y}`, true);
  current_path.push([current_x, current_y]);

  // *** NEW: Give each path a random max length ***
  const max_length = irand(4, 128);

  // This loop will run as long as the path can find a new step
  while (current_path.length < max_length) {
    // *** MODIFIED: Check length ***
    const neighbors: [number, number, number, number][] = []; // [dx, dy, nx, ny]

    // Check all 4 cardinal directions
    const directions = [
      [0, -1], // Up
      [0, 1], // Down
      [-1, 0], // Left
      [1, 0], // Right
    ];

    for (const [dx, dy] of directions) {
      const next_x = current_x + dx;
      const next_y = current_y + dy;

      // Check if neighbor is in bounds
      if (next_x < 0 || next_x >= cols || next_y < 0 || next_y >= rows) {
        continue;
      }

      // Check if neighbor is unvisited
      if (grid_map.get(`${next_x},${next_y}`) === false) {
        neighbors.push([dx, dy, next_x, next_y]);
      }
    }

    // If there are no unvisited neighbors, the path is stuck
    if (neighbors.length === 0) {
      break; // Exit the while loop, this path is done
    }

    // Pick a random neighbor to move to
    const [dx, dy, next_x, next_y] = neighbors[irand(0, neighbors.length - 1)];

    // Move to the new cell
    current_x = next_x;
    current_y = next_y;

    // Mark the new cell as visited
    grid_map.set(`${current_x},${current_y}`, true);

    // Add the new cell to our path
    current_path.push([current_x, current_y]);
  }

  // The while loop broke, so the path is finished
  paths.push(current_path);
}

// Define Command types for Path2
type MoveCommand = ['M', number, number];
type LineCommand = ['L', number, number];
type Command = MoveCommand | LineCommand;

// 3. Helper function to convert a path array to Path2 commands
function createPathData(path: [number, number][]): Command[] {
  if (path.length === 0) return [];

  const half_cell = CELL_SIZE / 2;
  const commands: Command[] = [];

  // Start with the 'Move to' command
  const [startX, startY] = path[0];
  commands.push(['M', startX * CELL_SIZE + half_cell, startY * CELL_SIZE + half_cell]);

  // Add 'Line to' commands for the rest
  for (let i = 1; i < path.length; i++) {
    const [x, y] = path[i];
    commands.push(['L', x * CELL_SIZE + half_cell, y * CELL_SIZE + half_cell]);
  }

  return commands;
}
---

<BaseLayout title="playground:traveling-paths" fullScreen={true}>
  <svg viewBox="0 0 1024 1024" id="sketch">
    <defs>
      <filter id="grain" x="0" y="0" width="100%" height="100%">
        <feTurbulence type="fractalNoise" baseFrequency="0.5" numOctaves="2"></feTurbulence>
        <!-- <feColorMatrix type="saturate" values="0"></feColorMatrix> -->
        <feComponentTransfer>
          <feFuncR type="linear" slope="4" intercept="-1.5"></feFuncR>
          <feFuncG type="linear" slope="4" intercept="-1.5"></feFuncG>
          <feFuncB type="linear" slope="4" intercept="-1.5"></feFuncB>
          <!-- <feFuncA type="linear" slope="0.35"></feFuncA> -->
        </feComponentTransfer>
        <!-- <feBlend in2="SourceGraphic" mode="add"></feBlend> -->
      </filter>
    </defs>
    <G translate={[512, 512]}>
      <G translate={[(-cols * CELL_SIZE) / 2, (-rows * CELL_SIZE) / 2]}>
        <!-- <Rect width={cols * CELL_SIZE} height={rows * CELL_SIZE} fill="#325" fill-opacity={0.9} /> -->
        <Rect width={cols * CELL_SIZE} height={rows * CELL_SIZE} fill="black" />
        <G>
          {
            paths.map((path) => {
              const d = createPathData(path);
              return (
                <Path2
                  d={d}
                  stroke={randomColor()}
                  fill="none"
                  stroke-width={irand(1, 3)}
                  stroke-linecap="round"
                  stroke-linejoin={'round'}
                />
              );
            })
          }
        </G>
        <Rect
          width={cols * CELL_SIZE}
          height={rows * CELL_SIZE}
          filter="url(#grain)"
          opacity={0.35}
        />
      </G>
    </G>
  </svg>

  <button>Download SVG</button>
</BaseLayout>

<script>
  import { downloadSvgAsImage } from '@lib/util/render-svg';

  const button = document.querySelector('button');

  button?.addEventListener('click', downloadSvg);

  function downloadSvg() {
    const svg = document.querySelector('#sketch') as SVGSVGElement;
    if (!svg) return;
    downloadSvgAsImage(svg, { scale: 2 });
  }
</script>

<style>
  svg {
    width: 100%;
    height: 100%;
  }

  svg path:hover {
    filter: invert(1) saturate(1.2) contrast(1.1) brightness(1.1);
  }
</style>
