---
import G from '@lib/components/svg/builtin/G.astro';
import Path2, { type Command } from '@lib/components/svg/builtin/Path2.astro';
import Rect from '@lib/components/svg/builtin/Rect.astro';
import BaseLayout from '@lib/layouts/BaseLayout.astro';
import { clamp } from 'src/lib/util/map';
import { chance, irand, pick } from 'src/lib/util/stokhos';

const grid_map = new Map<string, boolean>();
const grid_points: [number, number][] = [];

const cols = 256;
const rows = 256;
const cell_size = 4;
const max_path_length_bound = 128;
let actual_max_path_length = 0;

let colors = [
  [15, 100, 50],
  [30, 90, 60],
  [90, 80, 20],
  [140, 40, 20],
  [220, 20, 40],
];

const randomColor = () =>
  `hsl(${pick(
    colors.map((c) => {
      let saturation_offset = irand(-10, 20);
      let saturation = c[1] + saturation_offset;
      let lightness_offset = irand(-10, 20);
      let lightness = c[2] + lightness_offset;

      saturation = clamp(saturation, 0, 100);
      lightness = clamp(lightness, 0, 100);

      return [c[0], saturation, lightness].join(' ');
    })
  )}%)`;

for (let y = 0; y < rows; y++) {
  for (let x = 0; x < cols; x++) {
    grid_points.push([x, y]);
    grid_map.set(`${x},${y}`, false);
  }
}

grid_points.sort(() => 0.5 - Math.random());

const paths: [number, number][][] = [];

for (const [x, y] of grid_points) {
  if (grid_map.get(`${x},${y}`)) continue;

  const path: [number, number][] = [];
  let current_point: [number, number] = [x, y];

  grid_map.set(`${x},${y}`, true);
  path.push([x, y]);

  let max_length = irand(4, max_path_length_bound);

  while (path.length < max_length) {
    const directions = [
      [-1, -1],
      [1, -1],
      [-1, 1],
      [1, 1],
    ];

    const neighbors: [number, number][] = [];

    for (const [dx, dy] of directions) {
      const next_point: [number, number] = [current_point[0] + dx, current_point[1] + dy];

      if (next_point[0] < 0 || next_point[0] >= cols || next_point[1] < 0 || next_point[1] >= rows)
        continue;

      if (grid_map.get(`${next_point[0]},${next_point[1]}`) === false) {
        neighbors.push(next_point);
      }
    }

    if (neighbors.length === 0) break;

    const next_point = pick(neighbors);
    current_point = next_point;

    grid_map.set(`${current_point[0]},${current_point[1]}`, true);
    path.push(current_point);
  }

  paths.push(path);
  actual_max_path_length = Math.max(actual_max_path_length, path.length);
}
---

<BaseLayout title="playground:traveling-paths-2" fullScreen={true}>
  <svg viewBox="0 0 1024 1024" id="sketch">
    <defs>
      <filter id="grain" x="0" y="0" width="100%" height="100%">
        <feTurbulence type="fractalNoise" baseFrequency="0.5" numOctaves="2"></feTurbulence>
        <!-- <feColorMatrix type="saturate" values="0"></feColorMatrix> -->
        <feComponentTransfer>
          <feFuncR type="linear" slope="4" intercept="-1.5"></feFuncR>
          <feFuncG type="linear" slope="4" intercept="-1.5"></feFuncG>
          <feFuncB type="linear" slope="4" intercept="-1.5"></feFuncB>
          <!-- <feFuncA type="linear" slope="0.35"></feFuncA> -->
        </feComponentTransfer>
        <!-- <feBlend in2="SourceGraphic" mode="add"></feBlend> -->
      </filter>
    </defs>
    <G translate={[512, 512]}>
      <G translate={[(-cols * cell_size) / 2, (-rows * cell_size) / 2]}>
        <Rect
          width={cols * cell_size}
          height={rows * cell_size}
          fill={'#191121'}
          opacity={1}
          stroke="none"
        />
        {
          paths.map((path) => {
            if (path.length === 0) return null;

            let color = randomColor();
            let stroke_opacity = clamp(path.length / actual_max_path_length, 0.8, 1);
            let stroke_width = irand(1, 4);
            let stroke_dasharray = chance(0.5) ? `${irand(1, 3)}` : undefined;

            let half_cell = cell_size / 2;

            let commands = path.map((point, index) => {
              let x = point[0] * cell_size + half_cell;
              let y = point[1] * cell_size + half_cell;

              if (index === 0) return ['M', x, y] as Command;

              return ['L', x, y] as Command;
            });

            return (
              <Path2
                stroke={color}
                stroke-opacity={stroke_opacity}
                stroke-width={stroke_width}
                stroke-dasharray={stroke_dasharray}
                stroke-linecap="round"
                stroke-linejoin="round"
                fill="none"
                d={commands}
              />
            );
          })
        }
        <Rect
          width={cols * cell_size}
          height={rows * cell_size}
          filter="url(#grain)"
          opacity={0.15}
        />
      </G>
    </G>
  </svg>
  <button>Download SVG</button>
</BaseLayout>

<script>
  import { downloadSvgAsImage } from '@lib/util/render-svg';

  const button = document.querySelector('button');

  button?.addEventListener('click', downloadSvg);

  function downloadSvg() {
    const svg = document.querySelector('#sketch') as SVGSVGElement;
    if (!svg) return;
    downloadSvgAsImage(svg, { scale: 2 });
  }
</script>

<style>
  svg {
    width: 100%;
    height: 100%;
  }
</style>
