---
import G from '@lib/components/svg/builtin/G.astro';
import type { Command } from '@lib/components/svg/builtin/Path2.astro';
import Path2 from '@lib/components/svg/builtin/Path2.astro';
import Rect from '@lib/components/svg/builtin/Rect.astro';
import Filter from '@lib/components/svg/shapes/Filter.astro';
import BaseLayout from '@lib/layouts/BaseLayout.astro';
import { clamp } from '@lib/util/map';
import { chance, irand } from '@lib/util/stokhos';

const cols = 192;
const rows = 192;
const viewbox_width = 1024;
const viewbox_height = 1024;
const cell_x_size = viewbox_width / cols;
const cell_y_size = viewbox_height / rows;

const grid_map = new Map<string, boolean>();
const grid_points: [number, number][] = [];

for (let y = 0; y < rows; y++) {
  for (let x = 0; x < cols; x++) {
    grid_map.set(`${x},${y}`, false);
    grid_points.push([x, y]);
  }
}

grid_points.sort(() => 0.5 - Math.random());

const paths: { path: Command[]; length: number }[] = [];
let longest_actual_path_length = 0;

for (const [x, y] of grid_points) {
  if (grid_map.get(`${x},${y}`)) continue;

  grid_map.set(`${x},${y}`, true);

  let current_x = x;
  let current_y = y;
  let current_path: Command[] = [];

  const directions = [
    [1, 1],
    [-1, -1],
    [1, -1],
    [-1, 1],
  ];

  function check_n_steps_in_direction(n: number, dx: number, dy: number) {
    const path: [number, number][] = [];
    for (let i = 0; i < n; i++) {
      const prev_x = current_x + dx * i;
      const prev_y = current_y + dy * i;

      const next_x = current_x + dx * (i + 1);
      const next_y = current_y + dy * (i + 1);

      if (next_x < 0 || next_x >= cols || next_y < 0 || next_y >= rows) continue;

      const dest = grid_map.get(`${next_x},${next_y}`);
      const flank1 = grid_map.get(`${prev_x},${next_y}`);
      const flank2 = grid_map.get(`${next_x},${prev_y}`);

      if (dest || flank1 || flank2) break;

      path.push([next_x, next_y]);
    }

    return path;
  }

  const MAX_PATH_SEGMENTS = irand(1, 12);
  let path_segments = 0;
  let actual_path_length = 0;

  while (true) {
    if (path_segments >= MAX_PATH_SEGMENTS) break;

    let longest_path: [number, number][] = [];
    for (const [dx, dy] of directions) {
      const path = check_n_steps_in_direction(chance(0.4) ? irand(2, 8) : irand(8, 32), dx, dy);
      if (path.length > longest_path.length) {
        longest_path = path;
      }
    }

    if (longest_path.length === 0) break;
    actual_path_length += longest_path.length;

    current_x = longest_path[longest_path.length - 1][0];
    current_y = longest_path[longest_path.length - 1][1];

    current_path.push(['L', current_x * cell_x_size + 0.5, current_y * cell_y_size + 0.5]);

    longest_path.forEach(([x, y]) => {
      grid_map.set(`${x},${y}`, true);
    });

    path_segments++;
  }

  if (current_path.length > 0) {
    current_path.unshift(['M', x * cell_x_size + 0.5, y * cell_y_size + 0.5]);
    paths.push({ path: current_path, length: actual_path_length });
    longest_actual_path_length = Math.max(longest_actual_path_length, actual_path_length);
  }
}
console.log(`longest_actual_path_length: ${longest_actual_path_length}`);

// const colors = ['yellow', 'orange', 'red', 'purple', 'blue', 'black'];
let colors = [
  // [20, 10, 20],
  // [40, 70, 50],
  // [70, 80, 60],
  // [130, 25, 85],
  [10, 10, 20],
  [15, 100, 50],
  [30, 90, 60],
  [90, 20, 80],
];

const get_color_by_index = (index: number) => {
  const [hue, sat, light] = colors[index]; // Get the base color

  let saturation_offset = irand(-10, 10) + (chance(0.1) ? irand(1, 3) * 20 : 0);
  let saturation = sat + saturation_offset;
  let lightness_offset = irand(-10, 10) + (chance(0.05) ? irand(1, 3) * 10 : 0);
  let lightness = light + lightness_offset;

  saturation = clamp(saturation, 0, 100);
  lightness = clamp(lightness, 0, 100);

  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  // return `hsl(${hue}, ${sat}%, ${light}%)`;
};

console.log(`cell_x_size: ${cell_x_size}, cell_y_size: ${cell_y_size}`);
---

<BaseLayout title="playground:shape-packing" fullScreen={true}>
  <svg viewBox="0 0 1024 1024" id="sketch">
    <defs>
      <filter id="grain" x="0" y="0" width="100%" height="100%">
        <feTurbulence type="fractalNoise" baseFrequency="0.4" numOctaves="3"></feTurbulence>
        <feComponentTransfer>
          <feFuncR type="linear" slope="5" intercept="-3"></feFuncR>
          <feFuncG type="linear" slope="5" intercept="-3"></feFuncG>
          <feFuncB type="linear" slope="5" intercept="-3"></feFuncB>
        </feComponentTransfer>
        <feColorMatrix type="saturate" values="0"></feColorMatrix>
        <feComponentTransfer>
          <feFuncA type="linear" slope="0.3" intercept="0" result="grain_alpha"></feFuncA>
        </feComponentTransfer>
        <feBlend in="SourceGraphic" in2="grain" mode="overlay"></feBlend>
      </filter>
      <Filter id="smudge">
        <feTurbulence type="fractalNoise" baseFrequency="0.5" numOctaves="2"></feTurbulence>
        <feDisplacementMap
          in="SourceGraphic"
          scale="2"
          xChannelSelector="R"
          yChannelSelector="G"
          result="displacement"></feDisplacementMap>
        <feComposite operator="arithmetic" in="SourceGraphic" k1="0.3" k2="0.5" k3="0.6" k4="0"
        ></feComposite>
      </Filter>
    </defs>
    <rect
      width="1024"
      height="1024"
      fill="#000"
      stroke="currentColor"
      stroke-width="0.25"
      stroke-dasharray="1"></rect>
    <G filter="url(#grain)">
      <G filter="url(#smudge)">
        {
          paths.map(({ path, length }) => {
            // console.log(`length: ${length}`);
            const color_index = Math.floor(
              (length / longest_actual_path_length) * (colors.length - 1)
            );
            const stroke = get_color_by_index(
              chance(0.75) ? irand(0, color_index + 1) : irand(0, colors.length)
            );
            // const stroke = get_color_by_index(irand(0, colors.length));
            const stroke_width = irand(1, cell_x_size + 1);
            return <Path2 d={path} fill="none" {stroke} stroke-width={stroke_width} />;
          })
        }
      </G>
    </G>
    <!-- <Rect width={1024} height={1024} filter="url(#grain)" opacity={1} /> -->
  </svg>
  <button>Download SVG</button>
</BaseLayout>

<script>
  import { downloadSvgAsImage } from '@lib/util/render-svg';

  const button = document.querySelector('button');

  button?.addEventListener('click', downloadSvg);

  function downloadSvg() {
    const svg = document.querySelector('#sketch') as SVGSVGElement;
    if (!svg) return;
    downloadSvgAsImage(svg, {
      scale: 2,
      mimeType: 'image/jpeg',
      quality: 0.9,
      fileName: 'shape-packing.jpeg',
    });
  }
</script>
<style>
  svg {
    width: 100%;
    height: 100%;
    overflow: visible;
  }
</style>
