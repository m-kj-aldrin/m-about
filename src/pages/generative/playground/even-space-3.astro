---
import G from "@lib/components/svg/builtin/G.astro";
import Rect from "@lib/components/svg/builtin/Rect.astro";
import Filter from "@lib/components/svg/shapes/Filter.astro";
import PatternMask from "@lib/components/svg/shapes/patterns/PatternMask.astro";
import BaseLayout from "@lib/layouts/BaseLayout.astro";
import { range } from "src/lib/util/iter";
import { chance, irand, pick, rand } from "src/lib/util/stokhos";

const grid_map = new Map<string, boolean>();
const grid_points: [number, number, number, number][] = [];

const rows = 64;
const cols = 64;

// Initialize grid map
for (let i = 0; i < rows; i++) {
  for (let j = 0; j < cols; j++) {
    grid_map.set(`${i},${j}`, false); // false = unoccupied
  }
}

// Create a 1D list of all cells, then shuffle it.
// This is a more robust way to randomize iteration.
const all_cells: [number, number][] = [];
for (let i = 0; i < rows; i++) {
  for (let j = 0; j < cols; j++) {
    all_cells.push([i, j]);
  }
}
all_cells.sort((a, b) => 0.5 - Math.random());

// Iterate over every cell in a random order
for (const cell of all_cells) {
  const [i, j] = cell;

  // Skip if this cell is already part of a rectangle
  if (grid_map.get(`${i},${j}`)) {
    continue;
  }

  // 1. Get attempted size and clamp to grid boundaries
  const atempted_width = chance(0.45) ? irand(1, 8) : irand(1, 3) * 32;
  const atempted_height = chance(0.825) ? atempted_width : chance(0.5) ? irand(1, 4) : irand(1, 3) * 32;
  const max_width = Math.min(atempted_width, cols - j);
  const max_height = Math.min(atempted_height, rows - i);

  // 2. Find the true available rectangle, starting from (i, j)

  let final_width = 0;

  // First, find the max width possible along the *starting row* (i)
  for (let x_offset = 0; x_offset < max_width; x_offset++) {
    if (grid_map.get(`${i},${j + x_offset}`)) {
      break; // Hit an occupied cell
    }
    final_width++;
  }

  if (final_width === 0) continue;

  let final_height = 0;
  // *** START OF LOGIC FIX ***
  // We need to store the width *before* checking a row,
  // in case that row fails and shrinks the width to 0.
  let last_good_width = final_width;

  // Now, with this width, check how far *down* we can go
  for (let y_offset = 0; y_offset < max_height; y_offset++) {
    // Check every cell in this *row* (i + y_offset)
    for (let x_offset = 0; x_offset < final_width; x_offset++) {
      if (grid_map.get(`${i + y_offset},${j + x_offset}`)) {
        // This row is blocked. We must *shrink* the final_width
        final_width = x_offset;
        break; // Stop checking this row
      }
    }

    // If the width was shrunk to 0, we can't go any further down.
    if (final_width === 0) {
      // We must restore the *previous* width,
      // because that was the last valid rectangle.
      final_width = last_good_width;
      break;
    }

    // This row was clear for the (possibly new) final_width,
    // so we can increment our height and store this as the new
    // last good width.
    final_height++;
    last_good_width = final_width;
  }
  // *** END OF LOGIC FIX ***

  // We must have at least a 1x1
  if (final_width === 0 || final_height === 0) {
    continue;
  }

  // 3. Mark all cells in the final rectangle as occupied
  for (let y_offset = 0; y_offset < final_height; y_offset++) {
    for (let x_offset = 0; x_offset < final_width; x_offset++) {
      grid_map.set(`${i + y_offset},${j + x_offset}`, true);
    }
  }

  // 4. Store the rectangle info
  grid_points.push([i, j, final_width, final_height]);
}

const gap = 4;
const cell_width = 8;
const cell_height = 8;

// Calculate actual content bounds
const content_width = cols * cell_width + gap * 10; // 168
const content_height = rows * cell_height + gap * 10; // 552
const content_x = -gap * 5; // -20
const content_y = -gap * 5; // -20

// Calculate viewBox to match content bounds exactly
const viewBox_x = content_x;
const viewBox_y = content_y;
const viewBox_width = content_width;
const viewBox_height = content_height;
---

<BaseLayout title="playground:even-space-3" fullScreen={true}>
  <svg viewBox={`${viewBox_x} ${viewBox_y} ${viewBox_width} ${viewBox_height}`} id="sketch">
    <PatternMask width={16} height={16} scale={[0.25, 0.25]} name="dots">
      <circle r={3} cx="4" cy="4" fill="white"></circle>
      <circle r={3} cx="12" cy="12" fill="white"></circle>
    </PatternMask>
    <Filter id="grains" width="100%" height="100%">
      <feTurbulence type="fractalNoise" baseFrequency="0.7" numOctaves="2"></feTurbulence>
      <feComponentTransfer >
        <feFuncR type="linear" slope="2" intercept="-0.2"></feFuncR>
      </feComponentTransfer>

      <feColorMatrix type="matrix" values="
        1 0 0 0 0
        1 0 0 0 0
        1 0 0 0 0
        0 0 0 1 0" result="first"> </feColorMatrix>
      <feTurbulence type="fractalNoise" baseFrequency="0.003" numOctaves="4"></feTurbulence>

      <feGaussianBlur stdDeviation="3"></feGaussianBlur>

      <feComponentTransfer >
        <feFuncR type="linear" slope="2" intercept="-0.2"></feFuncR>
      </feComponentTransfer>

      <feColorMatrix type="matrix" values="
        1 0 0 0 0
        1 0 0 0 0
        1 0 0 0 0
        0 0 0 1 0" result="second"> </feColorMatrix>

      <feBlend in="first" in2="second" mode="multiply"></feBlend>
    </Filter>
    <!-- <filter id="grain" x="0" y="0" width="100%" height="100%">
      <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="1"></feTurbulence>
      <feComponentTransfer>
        <feFuncR type="linear" slope="5" intercept="-2"></feFuncR>
        <feFuncG type="linear" slope="5" intercept="-2"></feFuncG>
        <feFuncB type="linear" slope="5" intercept="-2"></feFuncB>
      </feComponentTransfer>
      <feColorMatrix type="saturate" values="0"></feColorMatrix>
      <feComponentTransfer>
        <feFuncA type="linear" slope="1" intercept="0" result="grain_alpha"></feFuncA>
      </feComponentTransfer>
      <feBlend in="SourceGraphic" in2="grain" mode="hard-light" result="hard"></feBlend>
      <feBlend in="SourceGraphic" in2="grain" mode="screen" result="overlay"></feBlend>

      <feComposite in="hard" in2="overlay" operator="arithmetic" k1="0.4" k2="0.9" k3="0.1" k4="0"></feComposite>
    </filter> -->
    <Filter id="smudge" x="-100%" y="-100%" width="200%" height="200%">
      <feTurbulence type="fractalNoise" baseFrequency="0.35" numOctaves="2"></feTurbulence>
      <feDisplacementMap in="SourceGraphic" scale="3.5" xChannelSelector="R" yChannelSelector="G" result="displacement"></feDisplacementMap>
      <feComposite operator="arithmetic" in="SourceGraphic" k1="0.3" k2="0.9" k3="0.2" k4="0"></feComposite>
    </Filter>
    <G>
      <Rect width={"100%"} height={"100%"} x={viewBox_x} y={viewBox_y} fill="hsl(30,80%,97%)" />
      <G translate={[content_width / 2 + content_x, content_height / 2 + content_y]}>
        {/* Center the grid visually. (cols * 16 / 2) = cols * 8 */}
        <G translate={[(-cols * cell_width) / 2, (-rows * cell_height) / 2]} filter="url(#smudge)">
          <G>
            <Rect
              width={cols * cell_width + gap * 4}
              height={rows * cell_height + gap * 4}
              x={-gap * 2}
              y={-gap * 2}
              stroke="currentColor"
              stroke-opacity={0.3}
              stroke-dasharray={`${gap / 2}`}
              fill="none"
            />
            <G translate={[gap / 2, gap / 2]}>
              {
                // _i = row, _j = col, _w = width, _h = height
                grid_points.map(([_i, _j, _w, _h]) => {
                  // Add a gap margin
                  let width = _w * cell_width - gap;
                  let height = _h * cell_height - gap;
                  // SVG 'x' is horizontal -> COLUMN (j)
                  let x = _j * cell_width;
                  // SVG 'y' is vertical -> ROW (i)
                  let y = _i * cell_height;
                  let rx = _w == 1 && _h == 1 ? Math.max(width, height) / 2 : 2;
                  let mask = chance(0.1) ? "url(#mask-dots)" : undefined;
                  let fill = mask
                    ? "currentColor"
                    : chance(0.1)
                      ? pick(["orangered", "navy", "currentColor", "currentColor", "currentColor", "currentColor"])
                      : "none";
                  let stroke = fill == "none" ? pick(["orangered", "navy", "currentColor", "currentColor", "currentColor", "currentColor"]) : undefined;
                  let strokeDasharray = stroke ? (chance(0.5) ? `${rand(0.25, 2)}` : undefined) : undefined;
                  let strokeWidth = stroke ? rand(0.75, 1.25) : undefined;
                  let strokeOpacity = strokeDasharray ? 1 : rand(0.3, 1);
                  return (
                    <G translate={[chance(0.1) ? irand(-1, 1) : 0, chance(0.1) ? irand(-1, 1) : 0]}>
                      <Rect
                        {x}
                        {y}
                        {width}
                        {height}
                        {rx}
                        {fill}
                        {mask}
                        {stroke}
                        stroke-width={strokeWidth}
                        stroke-dasharray={strokeDasharray}
                        stroke-opacity={strokeOpacity}
                      />
                    </G>
                  );
                })
              }
            </G>
          </G>
        </G>
      </G>
    </G>
    <Rect width={"100%"} height={"100%"} x={viewBox_x} y={viewBox_y} filter="url(#grains)" opacity={0.15} />
  </svg>
  <button>Download SVG</button>
</BaseLayout>

<script>
  import { downloadSvgAsImage } from "@lib/util/render-svg";

  const button = document.querySelector("button");

  button?.addEventListener("click", downloadSvg);

  function downloadSvg() {
    const svg = document.querySelector("#sketch") as SVGSVGElement;
    if (!svg) return;
    downloadSvgAsImage(svg, {
      scale: 2,
      mimeType: "image/jpeg",
      quality: 0.9,
      fileName: "even-space-3.jpeg",
    });
  }
</script>

<style>
  svg {
    width: auto;
    height: 100%;
    border: 1px #0002 dashed;
    margin: 0 auto;
  }
</style>
