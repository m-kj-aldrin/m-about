---
import TimeOfRender from "@lib/components/TimeOfRender.astro";
import BaseLayout from "@lib/layouts/BaseLayout.astro";
import type { ColorNames } from "@lib/types/colors";
import { IF, SWITCH } from "@lib/utils/comperator";
import { bm_chance, chance, pick } from "@lib/utils/stokhos";

export const prerender = false;

const params = Astro.url.searchParams;

let paramCellSize = +params.get("gridCellSize") || 4;

let w = `[${params.get("validWidths")?.trim().replaceAll(" ", ",")}]`;
let h = `[${params.get("validHeights")?.trim().replaceAll(" ", ",")}]`;
let gap = params.get("gap") ?? 2;

let paramWidths = [4, 16, 32, 64, 128, 256];
let paramHeights = [4, 16, 64, 256];
try {
    paramWidths = JSON.parse(w);
} catch {}

try {
    paramHeights = JSON.parse(h);
} catch {}

const planeWidth = 512;
const planeHeight = 512;
const gridCellSize = paramCellSize;

const validWidths = paramWidths;
const validHeights = paramHeights;

const gridWidth = Math.ceil(planeWidth / gridCellSize);
const gridHeight = Math.ceil(planeHeight / gridCellSize);
const grid = Array.from({ length: gridHeight }, () =>
    Array(gridWidth).fill(false)
);

function getRandomElement(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

function canPlaceRectangle(gridX, gridY, rectWidth, rectHeight) {
    if (
        gridX + rectWidth > grid[0].length ||
        gridY + rectHeight > grid.length
    ) {
        return false;
    }

    for (let i = gridY; i < gridY + rectHeight; i++) {
        for (let j = gridX; j < gridX + rectWidth; j++) {
            if (grid[i][j]) {
                return false;
            }
        }
    }

    return true;
}

function markGrid(gridX, gridY, rectWidth, rectHeight) {
    for (let i = gridY; i < gridY + rectHeight; i++) {
        for (let j = gridX; j < gridX + rectWidth; j++) {
            grid[i][j] = true;
        }
    }
}

function placeRectangles(planeWidth, planeHeight, validWidths, validHeights) {
    const rectangles = [];

    for (let y = 0; y < planeHeight; y += gridCellSize) {
        for (let x = 0; x < planeWidth; x += gridCellSize) {
            const gridX = Math.floor(x / gridCellSize);
            const gridY = Math.floor(y / gridCellSize);

            if (!grid[gridY][gridX]) {
                let placed = false;

                let height = getRandomElement(validHeights);
                let width = getRandomElement(validWidths);
                const rectGridWidth = Math.ceil(width / gridCellSize);
                const rectGridHeight = Math.ceil(height / gridCellSize);

                if (
                    canPlaceRectangle(
                        gridX,
                        gridY,
                        rectGridWidth,
                        rectGridHeight
                    )
                ) {
                    rectangles.push({ x, y, width, height });
                    markGrid(gridX, gridY, rectGridWidth, rectGridHeight);
                    placed = true;
                }

                if (!placed) {
                    for (let h of validHeights) {
                        for (let w of validWidths) {
                            const gridWidth = Math.ceil(w / gridCellSize);
                            const gridHeight = Math.ceil(h / gridCellSize);

                            if (
                                canPlaceRectangle(
                                    gridX,
                                    gridY,
                                    gridWidth,
                                    gridHeight
                                )
                            ) {
                                rectangles.push({ x, y, width: w, height: h });
                                markGrid(gridX, gridY, gridWidth, gridHeight);
                                placed = true;
                                break;
                            }
                        }
                        if (placed) break;
                    }
                }
            }
        }
    }

    return rectangles;
}

const rectangles = placeRectangles(
    planeWidth,
    planeHeight,
    validWidths,
    validHeights
);

const COLORS: ColorNames[] = ["primary", "secondary", "ternary", "offset"];
---

<script>
    let gapRange = document.querySelector(
        'form input[name="gap"]'
    ) as HTMLInputElement;
    gapRange.addEventListener("input", (e) => {
        if (!(e.target instanceof HTMLInputElement)) return;
        let value = e.target.value;
        document
            .querySelector("#graphic")
            .style.setProperty("--grid-gap", value);
    });
</script>

<BaseLayout title="fit-square" fullScreen={true}>
    <div id="graphic" style={`--grid-gap:${gap}`}>
        <form method="get">
            <label>
                grid cell size:&nbsp;
                <input
                    type="number"
                    name="gridCellSize"
                    value={paramCellSize}
                    min="1"
                />
            </label>
            <label>
                valid widths:&nbsp;
                <input
                    type="text"
                    name="validWidths"
                    value={validWidths.join(" ")}
                />
            </label>
            <label>
                valid heights:&nbsp;
                <input
                    type="text"
                    name="validHeights"
                    value={validHeights.join(" ")}
                />
            </label>
            <label>
                gap:
                <input
                    transition:persist="grid-gap-range"
                    type="range"
                    name="gap"
                    min="0"
                    max="8"
                    value={gap}
                />
            </label>
            <input type="submit" value={"new"} />
        </form>
        <span>
            <TimeOfRender />
        </span>
        <svg viewBox="-256 -256 512 512">
            <g transform="translate(-256 -256)">
                <g>
                    {
                        rectangles.map(({ x, y, width, height }) => {
                            let colorBase = (colType) =>
                                `hsl(var(--color-${colType}))`;
                            let squareColor = colorBase(pick(COLORS));
                            let circleColor = colorBase(pick(COLORS));
                            let minSize = Math.min(width, height);

                            return (
                                <g transform={`translate(${x} ${y})`}>
                                    <g
                                        class="cell"
                                        style={`--w:${width};--h:${height}`}
                                    >
                                        <rect
                                            {width}
                                            {height}
                                            fill={squareColor}
                                        />
                                        {IF(
                                            chance(0.25),
                                            <g
                                                transform={`translate(${width / 2} ${height / 2})`}
                                            >
                                                {SWITCH({
                                                    circle: (
                                                        <circle
                                                            r={
                                                                (minSize / 2) *
                                                                0.75
                                                            }
                                                            fill={circleColor}
                                                        />
                                                    ),
                                                    square: (
                                                        <rect
                                                            width={minSize}
                                                            height={minSize}
                                                            x={-minSize / 2}
                                                            y={-minSize / 2}
                                                            fill={circleColor}
                                                        />
                                                    ),
                                                })(pick(["square", "circle"]))}
                                            </g>
                                        )}
                                    </g>
                                </g>
                            );
                        })
                    }
                </g>
            </g>
        </svg>
    </div>
</BaseLayout>

<style>
    div {
        display: flex;
        flex-direction: column;
        height: 100%;

        align-items: center;
        margin-inline: auto;
        gap: 4px;
    }
    svg {
        padding: 4px;
    }
    svg .cell {
        transform: scale(
            calc((var(--w) - var(--grid-gap)) / var(--w)),
            calc((var(--h) - var(--grid-gap)) / var(--h))
        );
    }
</style>
