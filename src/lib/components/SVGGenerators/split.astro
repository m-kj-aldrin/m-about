---
import { IF } from "@u/comperator";
import { rand } from "@u/stokhos";

interface Props{
  depth?: number;
}

const {depth=3} = Astro.props

interface Pos {
  x: number;
  y: number;
}

export const prerender = false

interface TreeNode {
  pos: Pos;
  h?: number;
  w?: number;
  rbox?: { w: number; h: number };
  lbox?: { w: number; h: number };
  rot?: "h" | "v";
  depth?: number;
  side?: "left" | "right" | "first";
  last?: boolean;
}

let tree: TreeNode[] = [];
let n = depth;
const split = ({ pos, h = 1, w = 1, side = "first", depth = 0 }: TreeNode) => {
  if (depth > n || h < 0.05 || w < 0) {
    return;
  }
  let isVertical = rand() > 0.45;

  const delim = rand();
  let aPos = { x: 0, y: 0 };
  let wA = w,
    wB = w,
    hA = h,
    hB = h;
  if (isVertical) {
    // w
    wA = delim * w;
    wB = (1 - delim) * w;
    aPos = { x: pos.x, y: pos.y };
    pos = { x: pos.x + wA, y: pos.y };
  } else {
    // h
    hA = delim * h;
    hB = (1 - delim) * h;
    aPos = { x: pos.x, y: pos.y };
    pos = { x: pos.x, y: pos.y + hA };
  }

  split({ pos: aPos, w: wA, h: hA, depth: depth + 1, side: "left" });
  split({ pos, w: wB, h: hB, depth: depth + 1, side: "right" });

  tree.push({
    pos,
    depth,
    h,
    w,
    lbox: { w: wA, h: hA },
    rbox: { w: wB, h: hB },
    rot: isVertical ? "v" : "h",
    side,
    last: depth === n,
  });
};
split({ pos: { x: 0, y: 0 } });
---
<svg viewBox="0 0 256 256" width="100%" height="100%">
    <defs>
      <pattern width="4" height="4" id="dots" patternUnits="userSpaceOnUse">
        <g>
          <circle fill="currentColor" cx="2" cy="2" r="0.5"></circle>
        </g>
      </pattern>
    </defs>
    <g>
      <g transform="translate(0 0) scale(0.98)" transform-origin="center" filter="url(#filter-scrible)">
        <g transform="scale(0.975)" transform-origin="center" stroke-linecap="round" stroke-width="0.75">
          {
          tree.map(o => {
            return (
              <g stroke="currentColor" data-side={o.side} data-depth={o.depth} transform={`translate(${o.pos.x * 256} ${o.pos.y * 256})`}>
                <g fill="none">
                  <path d={`M0,0 ${o.rot}${256 * (o.rot==="v" ? o.h : o.w)}`} />
                </g>
                {IF(o.last,()=>{
                  return (
                    <g data-rot={o.rot} transform={`${o.rot==='h' ? 'rotate(180)' : "" }`}>
                      <polygon points={`0,0 0,${ o.lbox.h*256 } ${-o.lbox.w*256},${o.lbox.h*256} ${-o.lbox.w*256},0`} fill={`${rand()>0.5 ? "hsl(var(--color-secondary))" : "none"}`} />
                    </g>
      
                    <g transform={`translate(${(o.rbox.w / 2) * 256} ${ (o.rbox.h / 2) * 256 }) scale(1)`}>
                      <rect x={(-o.rbox.w / 2) * 256} y={(-o.rbox.h / 2) * 256} stroke="hsl(var(--color-ternary))" fill={`${rand()> 0.25 ? "url(#dots)" : "none"}`}
                        width={o.rbox.w * 256}
                        height={o.rbox.h * 256}
                        />
                        {IF(rand() > 0.85,() => {
                          return (
                            <g stroke="none">
                              <circle fill={rand()>0.85 ? "hsl(var(--color-primary))" : "currentColor"}
                                r={Math.min(o.rbox.w, o.rbox.h) * 96}
                                />
                            </g>
                          )
                        })}
                    </g>
                  )
                })}
              </g>
              <g>
                <rect stroke="none" x="-1" y="-1" width="2" height="2" fill="hsl(var(--color-ternary))" />
              </g>
            );
          })
          }
        </g>
        <rect width="100%" height="100%" fill="none" stroke="currentColor" stroke-dasharray="2" rx="2" stroke-width="0.5"></rect>
      </g>
    </g>
  </svg>

  <style>

  [data-side="right"] {
    stroke: hsl(var(--color-primary));
  }

  circle[fill="hsl(var(--color-primary))"] {
    transform: scale(0.25);
  }
  </style>